import { describe, it, expect } from 'vitest'
import {
  extractTextFromContent,
  extractAllTextFromContent,
  isSystemMessage,
  hasNoVisibleContent,
} from '../message-utils'
import { makeChatMessage, makeUserMessage, makeAssistantMessage } from './helpers'

describe('extractTextFromContent', () => {
  it('returns string content directly', () => {
    expect(extractTextFromContent('hello world')).toBe('hello world')
  })

  it('extracts text from array with single text block', () => {
    expect(extractTextFromContent([{ type: 'text', text: 'hello' }])).toBe('hello')
  })

  it('returns first text block from mixed content', () => {
    expect(
      extractTextFromContent([
        { type: 'tool_use', id: 't1', name: 'Read', input: {} },
        { type: 'text', text: 'the answer' },
      ]),
    ).toBe('the answer')
  })

  it('returns empty string for array with only tool blocks', () => {
    expect(extractTextFromContent([{ type: 'tool_use', id: 't1', name: 'Read', input: {} }])).toBe(
      '',
    )
  })

  it('returns empty string for empty array', () => {
    expect(extractTextFromContent([])).toBe('')
  })

  it('returns empty string for tool_result only', () => {
    expect(
      extractTextFromContent([{ type: 'tool_result', tool_use_id: 't1', content: 'result' }]),
    ).toBe('')
  })
})

describe('extractAllTextFromContent', () => {
  it('returns string content directly', () => {
    expect(extractAllTextFromContent('hello world')).toBe('hello world')
  })

  it('concatenates multiple text blocks with newlines', () => {
    expect(
      extractAllTextFromContent([
        { type: 'text', text: 'first' },
        { type: 'text', text: 'second' },
      ]),
    ).toBe('first\nsecond')
  })

  it('skips tool_use and tool_result blocks', () => {
    expect(
      extractAllTextFromContent([
        { type: 'text', text: 'opening' },
        { type: 'tool_use', id: 't1', name: 'Read', input: {} },
        { type: 'tool_result', tool_use_id: 't1', content: 'file contents' },
        { type: 'text', text: 'closing' },
      ]),
    ).toBe('opening\nclosing')
  })

  it('returns empty string for array with only tool blocks', () => {
    expect(
      extractAllTextFromContent([{ type: 'tool_use', id: 't1', name: 'Read', input: {} }]),
    ).toBe('')
  })

  it('returns empty string for empty array', () => {
    expect(extractAllTextFromContent([])).toBe('')
  })
})

describe('isSystemMessage', () => {
  it('returns true for isMeta messages', () => {
    const msg = makeChatMessage({ isMeta: true })
    expect(isSystemMessage(msg)).toBe(true)
  })

  it('returns true for <command-name> prefix', () => {
    const msg = makeUserMessage('<command-name>/clear</command-name>')
    expect(isSystemMessage(msg)).toBe(true)
  })

  it('returns true for <local-command- prefix', () => {
    const msg = makeUserMessage('<local-command-caveat>some output</local-command-caveat>')
    expect(isSystemMessage(msg)).toBe(true)
  })

  it('returns true for Caveat: prefix', () => {
    const msg = makeUserMessage('Caveat: The messages below were generated by the user')
    expect(isSystemMessage(msg)).toBe(true)
  })

  it('returns true for <system-reminder> prefix', () => {
    const msg = makeUserMessage('<system-reminder>Plan mode is active</system-reminder>')
    expect(isSystemMessage(msg)).toBe(true)
  })

  it('returns false for normal user message', () => {
    const msg = makeUserMessage('Help me fix a bug')
    expect(isSystemMessage(msg)).toBe(false)
  })

  it('returns false for normal assistant message', () => {
    const msg = makeAssistantMessage("I'll help you with that.")
    expect(isSystemMessage(msg)).toBe(false)
  })

  it('returns false when isMeta is undefined', () => {
    const msg = makeUserMessage('regular message')
    expect(msg.isMeta).toBeUndefined()
    expect(isSystemMessage(msg)).toBe(false)
  })

  it('handles array content with system prefix', () => {
    const msg = makeChatMessage({
      type: 'user',
      message: {
        role: 'user',
        content: [{ type: 'text', text: '<command-name>/help</command-name>' }],
      },
    })
    expect(isSystemMessage(msg)).toBe(true)
  })
})

describe('hasNoVisibleContent', () => {
  it('returns false for string content with text', () => {
    const msg = makeUserMessage('hello')
    expect(hasNoVisibleContent(msg)).toBe(false)
  })

  it('returns true for empty string content', () => {
    const msg = makeUserMessage('')
    expect(hasNoVisibleContent(msg)).toBe(true)
  })

  it('returns true for whitespace-only string content', () => {
    const msg = makeUserMessage('   \n\t  ')
    expect(hasNoVisibleContent(msg)).toBe(true)
  })

  it('returns false for array with visible text block', () => {
    const msg = makeChatMessage({
      type: 'assistant',
      message: {
        role: 'assistant',
        content: [{ type: 'text', text: 'visible content' }],
      },
    })
    expect(hasNoVisibleContent(msg)).toBe(false)
  })

  it('returns true for array with whitespace-only text block', () => {
    const msg = makeChatMessage({
      type: 'assistant',
      message: {
        role: 'assistant',
        content: [{ type: 'text', text: '   ' }],
      },
    })
    expect(hasNoVisibleContent(msg)).toBe(true)
  })

  it('returns true for array with only tool_use blocks', () => {
    const msg = makeChatMessage({
      type: 'assistant',
      message: {
        role: 'assistant',
        content: [{ type: 'tool_use', id: 't1', name: 'Read', input: {} }],
      },
    })
    expect(hasNoVisibleContent(msg)).toBe(true)
  })

  it('returns true for empty content array', () => {
    const msg = makeChatMessage({
      type: 'assistant',
      message: { role: 'assistant', content: [] },
    })
    expect(hasNoVisibleContent(msg)).toBe(true)
  })

  it('returns false for mixed content with at least one visible text block', () => {
    const msg = makeChatMessage({
      type: 'assistant',
      message: {
        role: 'assistant',
        content: [
          { type: 'tool_use', id: 't1', name: 'Read', input: {} },
          { type: 'text', text: '' },
          { type: 'text', text: 'visible' },
        ],
      },
    })
    expect(hasNoVisibleContent(msg)).toBe(false)
  })
})
